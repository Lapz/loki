{# THIS File is not automatically generated:
the below applies to the result of this template
#}
// This file is automatically generated based on the file `./generated.rs.tera` when `cargo xtask ast` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.
#![allow(bad_style, missing_docs, unreachable_pub)]
#![cfg_attr(rustfmt, rustfmt_skip)]


use TokenKind::*;
/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Debug,Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum TokenKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    EOF,

{%- for t in concat(a=single_byte_tokens, b=multi_byte_tokens) %}
    {{t.1}}, // {{t.0}}
{%- endfor -%}
{% for kw in concat(a=keywords) %}
    {{kw | upper}}_KW, // {{kw}}
{%- endfor -%}
{% for t in concat(a=literals, b=tokens) %}
    {{t}},
{%- endfor %}
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}



impl TokenKind {
    pub fn text(&self) -> &'static str {
        use TokenKind::*;
        match self {
        {%- for t in concat(a=single_byte_tokens, b=multi_byte_tokens) %}
            {{t.1}} => "{{t.0}}",
        {%- endfor -%}
        {% for kw in concat(a=keywords) %}
            {{kw | upper}}_KW => "{{kw}}",
        {%- endfor -%}
        {% for t in concat(a=literals, b=tokens) %}
            {{t}} => "{{t}}",
        {%- endfor %}
        
            _ => ""
        }
    }
}

{% for node, methods in ast %}
{% if methods.enum %}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum {{ node }} {
{% for kind in methods.enum %}
    {{ kind }},
{%- endfor %}
}
{%- endif -%}
{%if not methods.enum and not methods.collections and not methods.attributes %}
// {{ node }}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct {{ node }};
{% continue %}
{%endif%}
{%if not methods.enum %}
    // {{ node }}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct {{ node }} {
{% if methods.options -%}
{%- for m in methods.options -%}
{%- if m is string -%}
{%- set method_name = m | snake -%}
{%- set ChildName = m %}
{%- else -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
{%- endif %}
    pub {{ method_name }}:Option<{{ ChildName }}>,
{% endfor %}
{%- endif%}
{%- if methods.collections -%}
{%- for m in methods.collections -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
    pub {{ method_name }}:Vec<{{ ChildName }}>,
{% endfor -%}
{% endif %}
{%- if methods.attributes -%}
{%- for a in methods.attributes -%}
{%- set attr_name = a.0 -%}
{%- set ChildName = a.1 %}
    pub {{ attr_name }}:{{ ChildName }},
{% endfor -%}
{%- endif%}
}
{%- endif-%}
{%- endfor%}